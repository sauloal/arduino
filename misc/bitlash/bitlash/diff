diff --git a/src/bitlash-builtins.c b/src/bitlash-builtins.c
index af92cb0..3778d09 100644
--- a/src/bitlash-builtins.c
+++ b/src/bitlash-builtins.c
@@ -54,7 +54,7 @@ like this, from the command line:
 // use this define to add to the builtin_table
 #define BUILT_IN(name, script) name "\0" script "\0"
 
-prog_char builtin_table[] PROGMEM = {
+const prog_char builtin_table[] PROGMEM = {
 
 	// The banner must be first.  Add new builtins below.
 	BUILT_IN("banner",	
@@ -76,7 +76,7 @@ prog_char builtin_table[] PROGMEM = {
 
 
 byte findbuiltin(char *name) {
-prog_char *wordlist = builtin_table;
+const prog_char *wordlist = builtin_table;
 
 	while (pgm_read_byte(wordlist)) {
 		int result = strcmp_P(name, wordlist);
diff --git a/src/bitlash-cmdline.c b/src/bitlash-cmdline.c
index df4de0c..4bb938e 100644
--- a/src/bitlash-cmdline.c
+++ b/src/bitlash-cmdline.c
@@ -37,12 +37,12 @@ char lbuf[LBUFLEN];
 // Help text
 //
 #ifdef ARDUINO_BUILD
-prog_char helptext[] PROGMEM = { "http://bitlash.net\r\nSee LICENSE for license\r\nPins: d0-22,a0-22  Variables: a-z, 32 bit long integers\r\nOperators: + - * / ( ) < <= > >= == != << >> ! ^ & | ++ -- :=\r\nCommands: \0" };
+const prog_char helptext[] PROGMEM = { "http://bitlash.net\r\nSee LICENSE for license\r\nPins: d0-22,a0-22  Variables: a-z, 32 bit long integers\r\nOperators: + - * / ( ) < <= > >= == != << >> ! ^ & | ++ -- :=\r\nCommands: \0" };
 #else
-prog_char helptext[] PROGMEM = { "http://bitlash.net\r\n\0" };
+const prog_char helptext[] PROGMEM = { "http://bitlash.net\r\n\0" };
 #endif
 
-void showdict(prog_char *addr) {
+void showdict(const prog_char *addr) {
 byte c;
 	for (;;) {
 		c = pgm_read_byte(addr++);
diff --git a/src/bitlash-functions.c b/src/bitlash-functions.c
index 8a1136d..84757c8 100644
--- a/src/bitlash-functions.c
+++ b/src/bitlash-functions.c
@@ -188,7 +188,7 @@ numvar func_bitwrite(void) { reqargs(3); return arg3 ? func_bitset() : func_bitc
 //	MAINTENANCE NOTE: 	This dictionary must be sorted in alpha order 
 //						and must be 1:1 with function_table below.
 //
-prog_char functiondict[] PROGMEM = {
+const prog_char functiondict[] PROGMEM = {
 	"abs\0"
 	"ar\0"
 	"aw\0"
@@ -226,7 +226,7 @@ prog_char functiondict[] PROGMEM = {
 // this must be 1:1 with the symbols above, which in turn must be in alpha order
 //
 
-bitlash_function function_table[] PROGMEM = {
+const bitlash_function function_table[] PROGMEM = {
 	func_abs,
 	func_ar,
 	func_aw,
diff --git a/src/bitlash-parser.c b/src/bitlash-parser.c
index 2c958cc..80cc299 100644
--- a/src/bitlash-parser.c
+++ b/src/bitlash-parser.c
@@ -51,7 +51,7 @@ char idbuf[IDLEN+1];
 
 
 
-prog_char strings[] PROGMEM = { 
+const prog_char strings[] PROGMEM = { 
 #ifdef TINY85
 	"exp \0unexp \0mssng \0str\0 uflow \0oflow \0\0\0\0exp\0op\0\0eof\0var\0num\0)\0\0eep\0:=\"\0> \0line\0char\0stack\0startup\0id\0prompt\0\r\n\0\0\0"
 #else
@@ -60,8 +60,8 @@ prog_char strings[] PROGMEM = {
 };
 
 // get the address of the nth message in the table
-prog_char *getmsg(byte id) {
-	prog_char *msg = strings;
+const prog_char *getmsg(byte id) {
+	const prog_char *msg = strings;
 	while (id) { msg += strlen_P(msg) + 1; id--; }
 	return msg;
 }
@@ -70,7 +70,7 @@ prog_char *getmsg(byte id) {
 #if defined(HARDWARE_SERIAL_TX) || defined(SOFTWARE_SERIAL_TX)
 // print the nth string from the message table, e.g., msgp(M_missing);
 void msgp(byte id) {
-	prog_char *msg = getmsg(id);
+	const prog_char *msg = getmsg(id);
 	for (;;) {
 		char c = pgm_read_byte(msg++);
 		if (!c) break;
@@ -105,7 +105,7 @@ tokenhandler tokenhandlers[TOKENTYPES] = {
 //	The code corresponding to a character specifies which of the token handlers above will
 //	be called when the character is seen as the initial character in a symbol.
 #define np(a,b) ((a<<4)+b)
-prog_char chartypes[] PROGMEM = {    											//    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+const prog_char chartypes[] PROGMEM = {    											//    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
 	np(3,4), np(4,4),  np(4,4), np(4,4),  np(4,0), np(0,4),  np(4,0), np(4,4),	//0  NUL SOH STX ETX EOT ENQ ACK BEL BS  HT  LF  VT  FF  CR  SO  SI
 	np(4,4), np(4,4),  np(4,4), np(4,4),  np(4,4), np(4,4),  np(4,4), np(4,4),	//1  DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB ESC FS  GS  RS  US
 	np(0,8), np(7,7),  np(4,7), np(8,5),  np(7,7), np(7,8),  np(7,8), np(7,8),	//2   SP  !   "   #   $   %   &   '   (   )   *   +   ,   -   .   slash
@@ -352,11 +352,11 @@ void releaseargblock(void) {
 //	MUST BE IN ALPHABETICAL ORDER!
 //
 #ifdef TINY85
-prog_char reservedwords[] PROGMEM = { "boot\0if\0run\0stop\0switch\0while\0" };
-prog_uchar reservedwordtypes[] PROGMEM = { s_boot, s_if, s_run, s_stop, s_switch, s_while };
+const prog_char reservedwords[] PROGMEM = { "boot\0if\0run\0stop\0switch\0while\0" };
+const prog_uchar reservedwordtypes[] PROGMEM = { s_boot, s_if, s_run, s_stop, s_switch, s_while };
 #else
-prog_char reservedwords[] PROGMEM = { "arg\0boot\0else\0function\0help\0if\0ls\0peep\0print\0ps\0return\0rm\0run\0stop\0switch\0while\0" };
-prog_uchar reservedwordtypes[] PROGMEM = { s_arg, s_boot, s_else, s_function, s_help, s_if, s_ls, s_peep, s_print, s_ps, s_return, s_rm, s_run, s_stop, s_switch, s_while };
+const prog_char reservedwords[] PROGMEM = { "arg\0boot\0else\0function\0help\0if\0ls\0peep\0print\0ps\0return\0rm\0run\0stop\0switch\0while\0" };
+const prog_uchar reservedwordtypes[] PROGMEM = { s_arg, s_boot, s_else, s_function, s_help, s_if, s_ls, s_peep, s_print, s_ps, s_return, s_rm, s_run, s_stop, s_switch, s_while };
 #endif
 
 // find id in PROGMEM wordlist.  result in symval, return true if found.
@@ -474,8 +474,8 @@ void chrconst(void) {
 }
 
 
-prog_char twochartokens[] PROGMEM = { "&&||==!=++--:=>=>><=<<//" };
-prog_uchar twocharsyms[] PROGMEM = {
+const prog_char twochartokens[] PROGMEM = { "&&||==!=++--:=>=>><=<<//" };
+const prog_uchar twocharsyms[] PROGMEM = {
 	s_logicaland, s_logicalor, s_logicaleq, s_logicalne, s_incr, 
 	s_decr, s_define, s_ge, s_shiftright, s_le, s_shiftleft, s_comment
 };
@@ -485,7 +485,7 @@ void parseop(void) {
 	sym = inchar;		// think horse not zebra
 	fetchc();			// inchar has second char of token or ??
 
-	prog_char *tk = twochartokens;
+	const prog_char *tk = twochartokens;
 	byte index = 0;
 	for (;;) {
 		byte c1 = pgm_read_byte(tk++);
diff --git a/src/bitlash.h b/src/bitlash.h
index 9eea130..1c70b1e 100644
--- a/src/bitlash.h
+++ b/src/bitlash.h
@@ -488,8 +488,8 @@ void dofunctioncall(byte);
 numvar func_free(void);
 void beep(unumvar, unumvar, unumvar);
 
-extern prog_char functiondict[] PROGMEM;
-extern prog_char aliasdict[] PROGMEM;
+const extern prog_char functiondict[] PROGMEM;
+const extern prog_char aliasdict[] PROGMEM;
 
 void stir(byte);
 
@@ -592,7 +592,7 @@ void traceback(void);
 
 numvar func_fprintf(void);
 
-prog_char *getmsg(byte);
+const prog_char *getmsg(byte);
 void parsestring(void (*)(char));
 void msgp(byte);
 void msgpl(byte);
@@ -604,7 +604,7 @@ byte is_end(void);
 numvar getarg(numvar);
 void releaseargblock(void);
 void parsearglist(void);
-extern prog_char reservedwords[];
+const extern prog_char reservedwords[];
 
 
 
